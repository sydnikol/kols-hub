/**
 * ðŸ–¤ KOL DATABASE
 * Unified IndexedDB for all features with evolution tracking
 */

import Dexie, { Table } from 'dexie';

// Define all database tables and their schemas
export interface MedicationRecord {
  id?: number;
  drugName: string;
  genericName?: string;
  strength: string;
  dosage: string;
  frequency: string;
  prescriber?: string;
  pharmacy?: string;
  status: 'Active' | 'Inactive';
  startDate?: Date;
  endDate?: Date;
  refills?: number;
  notes?: string;
  lastTaken?: Date;
  nextDose?: Date;
}

export interface VitalRecord {
  id?: number;
  timestamp: Date;
  bloodPressureSystolic?: number;
  bloodPressureDiastolic?: number;
  heartRate?: number;
  oxygenLevel?: number;
  temperature?: number;
  notes?: string;
  tags?: string[];
}

export interface HydrationRecord {
  id?: number;
  timestamp: Date;
  waterIntake: number; // in mL
  sodiumIntake: number; // in mg
  notes?: string;
}

export interface PainRecord {
  id?: number;
  timestamp: Date;
  painLevel: number; // 1-10
  location: string[];
  triggers?: string[];
  reliefMethods?: string[];
  notes?: string;
}

export interface MoodRecord {
  id?: number;
  timestamp: Date;
  mood: string;
  energy: number; // spoons
  anxiety?: number; // 1-10
  notes?: string;
}

export interface FeatureIdea {
  id?: number;
  title: string;
  description: string;
  category: string;
  priority: 'P0' | 'P1' | 'P2' | 'P3';
  status: 'Backlog' | 'In Progress' | 'Complete';
  effort?: string;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface EvolutionLog {
  id?: number;
  timestamp: Date;
  event: string;
  category: string;
  data?: any;
  userAction?: string;
  systemResponse?: string;
}

export interface UserPreference {
  id?: number;
  key: string;
  value: any;
  updatedAt: Date;
}

export interface CourseProgress {
  id?: number;
  platform: string;
  courseName: string;
  provider: string;
  creditType: 'ACE' | 'CLEP' | 'DSST' | 'Coursera' | 'edX' | 'OpenStax' | 'Khan' | 'MIT' | 'Portfolio';
  creditHours: number;
  progress: number;
  timeSpent: number;
  startDate: string;
  completionDate?: string;
  certificateUrl?: string;
  costSavings: number;
  status: 'not-started' | 'in-progress' | 'completed' | 'paused';
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  tags: string[];
  notes: string;
  resumeReady: boolean;
}

export interface ResumeEntry {
  id?: number;
  type: 'education' | 'certification' | 'project' | 'skill' | 'volunteer' | 'achievement';
  title: string;
  organization: string;
  description: string;
  startDate: string;
  endDate?: string;
  ongoing: boolean;
  skills: string[];
  url?: string;
  verified: boolean;
  autoGenerated: boolean;
  sourceId?: string;
}

export interface AIConversation {
  id?: number;
  timestamp: Date;
  mode: 'companion' | 'creative' | 'archivist' | 'rebel';
  room: 'health' | 'art' | 'activism' | 'ancestry' | 'rest' | 'ritual';
  userMessage: string;
  aiResponse: string;
  context?: any;
}

export interface CachedTrack {
  id: string;
  title: string;
  artist: string;
  album?: string;
  thumbnail: string;
  duration: number;
  platform: 'spotify' | 'youtube' | 'soundcloud';
  url?: string;
  streamUrl?: string;
  isOfflineAvailable?: boolean;
  localPath?: string;
  searchQuery?: string;
  cachedAt?: Date;
}

export interface CachedPlaylist {
  id: string;
  name: string;
  description?: string;
  thumbnail?: string;
  platform: 'spotify' | 'youtube' | 'soundcloud';
  trackCount?: number;
  cachedAt?: Date;
}

// Extended database class
export class KolDatabase extends Dexie {
  medications!: Table<MedicationRecord>;
  vitals!: Table<VitalRecord>;
  hydration!: Table<HydrationRecord>;
  pain!: Table<PainRecord>;
  mood!: Table<MoodRecord>;
  features!: Table<FeatureIdea>;
  evolution!: Table<EvolutionLog>;
  preferences!: Table<UserPreference>;
  conversations!: Table<AIConversation>;
  education!: Table<CourseProgress>;
  resume!: Table<ResumeEntry>;
  cachedTracks!: Table<CachedTrack>;
  cachedPlaylists!: Table<CachedPlaylist>;

  constructor() {
    super('KolDatabase');

    this.version(3).stores({
      medications: '++id, drugName, status, startDate, lastTaken, nextDose',
      vitals: '++id, timestamp',
      hydration: '++id, timestamp',
      pain: '++id, timestamp, painLevel',
      mood: '++id, timestamp',
      features: '++id, title, category, priority, status, createdAt',
      evolution: '++id, timestamp, category, event',
      preferences: '++id, key, updatedAt',
      conversations: '++id, timestamp, mode, room',
      education: '++id, platform, courseName, status, progress, creditType',
      resume: '++id, type, title, organization, startDate',
      cachedTracks: 'id, title, artist, platform, searchQuery, cachedAt, isOfflineAvailable',
      cachedPlaylists: 'id, name, platform, cachedAt'
    });
  }

  // Helper method to log evolution events
  async logEvolution(event: string, category: string, data?: any) {
    await this.evolution.add({
      timestamp: new Date(),
      event,
      category,
      data
    });
  }

  // Get today's summary
  async getTodaySummary() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const [vitals, hydration, pain, mood, medications] = await Promise.all([
      this.vitals.where('timestamp').aboveOrEqual(today).toArray(),
      this.hydration.where('timestamp').aboveOrEqual(today).toArray(),
      this.pain.where('timestamp').aboveOrEqual(today).toArray(),
      this.mood.where('timestamp').aboveOrEqual(today).toArray(),
      this.medications.where('status').equals('Active').toArray()
    ]);

    // Calculate totals
    const totalWater = hydration.reduce((sum, h) => sum + h.waterIntake, 0);
    const totalSodium = hydration.reduce((sum, h) => sum + h.sodiumIntake, 0);
    const avgPain = pain.length > 0 
      ? pain.reduce((sum, p) => sum + p.painLevel, 0) / pain.length 
      : 0;

    return {
      date: today,
      vitals,
      hydration: {
        water: totalWater,
        sodium: totalSodium,
        entries: hydration
      },
      pain: {
        average: avgPain,
        entries: pain
      },
      mood: mood[mood.length - 1] || null,
      activeMedications: medications.length,
      medicationsDue: medications.filter(m => {
        if (!m.nextDose) return false;
        const next = new Date(m.nextDose);
        return next <= new Date();
      }).length
    };
  }

  // Import bulk data
  async importBulkData(table: string, data: any[]) {
    const tableRef = (this as any)[table];
    if (!tableRef) throw new Error(`Table ${table} not found`);
    
    await tableRef.bulkAdd(data);
    await this.logEvolution(`Imported ${data.length} records`, table);
  }

  // Clear all data (with confirmation)
  async clearAllData(confirm: string) {
    if (confirm !== 'DELETE_EVERYTHING_I_AM_SURE') {
      throw new Error('Confirmation string does not match');
    }

    await Promise.all([
      this.medications.clear(),
      this.vitals.clear(),
      this.hydration.clear(),
      this.pain.clear(),
      this.mood.clear(),
      this.features.clear(),
      this.evolution.clear(),
      this.preferences.clear(),
      this.conversations.clear()
    ]);

    await this.logEvolution('Database cleared', 'system');
  }
}

// Create and export database instance
export const db = new KolDatabase();

// Initialize database with default preferences
db.on('ready', async () => {
  const prefs = await db.preferences.toArray();
  
  if (prefs.length === 0) {
    // Set default preferences
    await db.preferences.bulkAdd([
      { key: 'theme', value: 'gothic-purple', updatedAt: new Date() },
      { key: 'spoonCount', value: 5, updatedAt: new Date() },
      { key: 'medicationReminders', value: true, updatedAt: new Date() },
      { key: 'hydrationGoal', value: 2500, updatedAt: new Date() },
      { key: 'sodiumGoal', value: 4000, updatedAt: new Date() },
      { key: 'aiMode', value: 'companion', updatedAt: new Date() },
      { key: 'avatarId', value: '68e94e474099d80b93c9b714', updatedAt: new Date() }
    ]);
    
    await db.logEvolution('Database initialized', 'system');
  }
});

// Export helper functions
export const getPreference = async (key: string): Promise<any> => {
  const pref = await db.preferences.where('key').equals(key).first();
  return pref?.value;
};

export const setPreference = async (key: string, value: any): Promise<void> => {
  const existing = await db.preferences.where('key').equals(key).first();
  
  if (existing) {
    await db.preferences.update(existing.id!, { value, updatedAt: new Date() });
  } else {
    await db.preferences.add({ key, value, updatedAt: new Date() });
  }
  
  await db.logEvolution(`Preference updated: ${key}`, 'preferences', { value });
};

export default db;